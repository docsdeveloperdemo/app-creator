import React, { useRef, useEffect, useState } from 'react';
import { Character } from '../types';

interface SpriteGeneratorProps {
  character: Character;
  isAnimating: boolean;
  currentFrame: number;
  onFrameChange: (frame: number) => void;
}

const SpriteGenerator: React.FC<SpriteGeneratorProps> = ({
  character,
  isAnimating,
  currentFrame,
  onFrameChange
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>();
  const [lastFrameTime, setLastFrameTime] = useState(0);

  // Enhanced walking animation with proper leg movement and body bob
  const generateWalkingFrame = (ctx: CanvasRenderingContext2D, frameIndex: number, direction: 'down' | 'up' | 'left' | 'right') => {
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0, 0, 32, 32);
    
    // Calculate animation variables
    const walkCycle = frameIndex % 4;
    const isStepFrame = walkCycle === 1 || walkCycle === 3;
    const isLeftStep = walkCycle === 1;
    const isRightStep = walkCycle === 3;
    
    // Body bob animation (subtle up/down movement)
    const bodyBob = isStepFrame ? 0 : 1;
    const baseY = 8 + bodyBob;
    
    // Leg positions for walking
    let leftLegOffset = 0;
    let rightLegOffset = 0;
    
    if (direction === 'down' || direction === 'up') {
      // Front/back walking - alternate leg positions
      if (isLeftStep) {
        leftLegOffset = 1;
        rightLegOffset = -1;
      } else if (isRightStep) {
        leftLegOffset = -1;
        rightLegOffset = 1;
      }
    } else {
      // Side walking - more pronounced leg movement
      if (isLeftStep) {
        leftLegOffset = direction === 'left' ? 1 : -1;
        rightLegOffset = direction === 'left' ? -1 : 1;
      } else if (isRightStep) {
        leftLegOffset = direction === 'left' ? -1 : 1;
        rightLegOffset = direction === 'left' ? 1 : -1;
      }
    }

    // Character base colors
    const skinColor = character.skinColor;
    const hairColor = character.hairColor;
    const outfitColor = character.outfitColor;
    
    // Shadow colors (darker versions)
    const skinShadow = darkenColor(skinColor, 0.3);
    const hairShadow = darkenColor(hairColor, 0.3);
    const outfitShadow = darkenColor(outfitColor, 0.3);

    // Draw shadow/ground contact
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(11, 30, 10, 2);

    // Draw legs with walking animation
    drawLegs(ctx, direction, leftLegOffset, rightLegOffset, baseY, outfitColor, outfitShadow);
    
    // Draw body/torso
    drawBody(ctx, direction, baseY, outfitColor, outfitShadow);
    
    // Draw arms with subtle swing
    drawArms(ctx, direction, frameIndex, baseY, skinColor, skinShadow, outfitColor);
    
    // Draw head
    drawHead(ctx, direction, baseY - 2, skinColor, skinShadow);
    
    // Draw hair
    drawHair(ctx, direction, baseY - 2, character.hairStyle, hairColor, hairShadow);
    
    // Add facial features
    drawFace(ctx, direction, baseY - 2);
  };

  // Helper function to draw legs with proper walking animation
  const drawLegs = (ctx: CanvasRenderingContext2D, direction: string, leftOffset: number, rightOffset: number, baseY: number, outfitColor: string, outfitShadow: string) => {
    const legY = baseY + 8;
    
    if (direction === 'left' || direction === 'right') {
      // Side view legs
      const frontLegX = direction === 'left' ? 13 : 15;
      const backLegX = direction === 'left' ? 15 : 13;
      
      // Back leg (drawn first)
      ctx.fillStyle = outfitShadow;
      ctx.fillRect(backLegX, legY + Math.abs(rightOffset), 3, 8 - Math.abs(rightOffset));
      
      // Front leg
      ctx.fillStyle = outfitColor;
      ctx.fillRect(frontLegX, legY + Math.abs(leftOffset), 3, 8 - Math.abs(leftOffset));
      
      // Feet
      ctx.fillStyle = '#4a4a4a'; // Dark gray shoes
      ctx.fillRect(frontLegX, legY + 8, 4, 2);
      if (Math.abs(rightOffset) === 0) {
        ctx.fillRect(backLegX, legY + 8, 4, 2);
      }
    } else {
      // Front/back view legs
      ctx.fillStyle = outfitColor;
      ctx.fillRect(13 + leftOffset, legY, 3, 8);
      ctx.fillRect(17 + rightOffset, legY, 3, 8);
      
      // Leg shadows
      ctx.fillStyle = outfitShadow;
      ctx.fillRect(13 + leftOffset + 2, legY, 1, 8);
      ctx.fillRect(17 + rightOffset + 2, legY, 1, 8);
      
      // Feet
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(12 + leftOffset, legY + 8, 4, 2);
      ctx.fillRect(17 + rightOffset, legY + 8, 4, 2);
    }
  };

  // Helper function to draw body
  const drawBody = (ctx: CanvasRenderingContext2D, direction: string, baseY: number, outfitColor: string, outfitShadow: string) => {
    const bodyWidth = direction === 'left' || direction === 'right' ? 8 : 10;
    const bodyX = direction === 'left' || direction === 'right' ? 12 : 11;
    
    // Main body
    ctx.fillStyle = outfitColor;
    ctx.fillRect(bodyX, baseY, bodyWidth, 10);
    
    // Body shading
    ctx.fillStyle = outfitShadow;
    if (direction === 'right') {
      ctx.fillRect(bodyX, baseY, 2, 10);
    } else if (direction === 'left') {
      ctx.fillRect(bodyX + bodyWidth - 2, baseY, 2, 10);
    } else {
      ctx.fillRect(bodyX + bodyWidth - 2, baseY, 2, 10);
    }
  };

  // Helper function to draw arms with subtle swing
  const drawArms = (ctx: CanvasRenderingContext2D, direction: string, frameIndex: number, baseY: number, skinColor: string, skinShadow: string, outfitColor: string) => {
    const armSwing = Math.sin(frameIndex * 0.5) * 0.5;
    
    if (direction === 'left') {
      // Left side view - one arm visible
      ctx.fillStyle = outfitColor;
      ctx.fillRect(20, baseY + 2 + armSwing, 3, 6);
      ctx.fillStyle = skinColor;
      ctx.fillRect(20, baseY + 8 + armSwing, 3, 4);
    } else if (direction === 'right') {
      // Right side view - one arm visible  
      ctx.fillStyle = outfitColor;
      ctx.fillRect(9, baseY + 2 + armSwing, 3, 6);
      ctx.fillStyle = skinColor;
      ctx.fillRect(9, baseY + 8 + armSwing, 3, 4);
    } else {
      // Front/back view - both arms
      ctx.fillStyle = outfitColor;
      ctx.fillRect(8, baseY + 2 + armSwing, 3, 6);
      ctx.fillRect(21, baseY + 2 - armSwing, 3, 6);
      
      ctx.fillStyle = skinColor;
      ctx.fillRect(8, baseY + 8 + armSwing, 3, 4);
      ctx.fillRect(21, baseY + 8 - armSwing, 3, 4);
      
      // Arm shading
      ctx.fillStyle = skinShadow;
      ctx.fillRect(10, baseY + 8 + armSwing, 1, 4);
      ctx.fillRect(23, baseY + 8 - armSwing, 1, 4);
    }
  };

  // Helper function to draw head
  const drawHead = (ctx: CanvasRenderingContext2D, direction: string, headY: number, skinColor: string, skinShadow: string) => {
    const headSize = 8;
    const headX = 12;
    
    // Main head
    ctx.fillStyle = skinColor;
    ctx.fillRect(headX, headY, headSize, headSize);
    
    // Head shading
    ctx.fillStyle = skinShadow;
    if (direction === 'right') {
      ctx.fillRect(headX, headY, 2, headSize);
    } else if (direction === 'left') {
      ctx.fillStyle = skinShadow;
      ctx.fillRect(headX + headSize - 2, headY, 2, headSize);
    } else {
      ctx.fillRect(headX + headSize - 2, headY, 2, headSize);
    }
  };

  // Helper function to draw hair
  const drawHair = (ctx: CanvasRenderingContext2D, direction: string, headY: number, hairStyle: string, hairColor: string, hairShadow: string) => {
    ctx.fillStyle = hairColor;
    
    switch (hairStyle.toLowerCase()) {
      case 'short':
        ctx.fillRect(11, headY - 1, 10, 3);
        ctx.fillRect(12, headY + 2, 8, 2);
        break;
      case 'long':
        ctx.fillRect(11, headY - 1, 10, 4);
        ctx.fillRect(10, headY + 3, 12, 8);
        break;
      case 'spiky':
        ctx.fillRect(11, headY - 2, 10, 2);
        ctx.fillRect(12, headY, 8, 3);
        // Spikes
        ctx.fillRect(13, headY - 3, 2, 1);
        ctx.fillRect(17, headY - 3, 2, 1);
        break;
      default:
        ctx.fillRect(11, headY - 1, 10, 3);
        break;
    }
    
    // Hair shading
    ctx.fillStyle = hairShadow;
    ctx.fillRect(18, headY - 1, 2, 4);
  };

  // Helper function to draw facial features
  const drawFace = (ctx: CanvasRenderingContext2D, direction: string, headY: number) => {
    // Eyes
    ctx.fillStyle = '#000';
    if (direction === 'left') {
      ctx.fillRect(17, headY + 2, 1, 1);
    } else if (direction === 'right') {
      ctx.fillRect(14, headY + 2, 1, 1);
    } else {
      ctx.fillRect(14, headY + 2, 1, 1);
      ctx.fillRect(17, headY + 2, 1, 1);
    }
    
    // Simple mouth
    if (direction !== 'up') {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(15, headY + 4, 2, 1);
    }
  };

  // Helper function to darken colors
  const darkenColor = (color: string, amount: number): string => {
    // Convert hex to RGB, darken, and convert back
    const hex = color.replace('#', '');
    const r = Math.max(0, Math.floor(parseInt(hex.substr(0, 2), 16) * (1 - amount)));
    const g = Math.max(0, Math.floor(parseInt(hex.substr(2, 2), 16) * (1 - amount)));
    const b = Math.max(0, Math.floor(parseInt(hex.substr(4, 2), 16) * (1 - amount)));
    
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  };

  // Animation loop
  useEffect(() => {
    if (!isAnimating) return;

    const animate = (timestamp: number) => {
      if (timestamp - lastFrameTime >= 200) { // 200ms per frame = 5fps
        onFrameChange((currentFrame + 1) % 32);
        setLastFrameTime(timestamp);
      }
      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isAnimating, currentFrame, lastFrameTime, onFrameChange]);

  // Render current frame
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Determine direction and frame within that direction
    const directions = ['down', 'left', 'right', 'up'] as const;
    const directionIndex = Math.floor(currentFrame / 8);
    const frameInDirection = currentFrame % 8;
    const direction = directions[directionIndex];

    generateWalkingFrame(ctx, frameInDirection, direction);
  }, [character, currentFrame]);

  return (
    <div className="bg-gray-700 p-4 rounded-lg">
      <h3 className="text-white text-lg font-bold mb-4">Character Sprite</h3>
      <div className="bg-gray-600 p-4 rounded">
        <canvas
          ref={canvasRef}
          width={32}
          height={32}
          className="border-2 border-gray-400 bg-gray-500"
          style={{
            imageRendering: 'pixelated',
            width: '128px',
            height: '128px'
          }}
        />
        <p className="text-gray-300 text-sm mt-2">32x32 pixel enhanced sprite</p>
        <p className="text-gray-300 text-xs">Late 90s RPG style with walking animation</p>
      </div>
    </div>
  );
};

export default SpriteGenerator;